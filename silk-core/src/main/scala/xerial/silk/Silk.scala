package xerial.silk

import java.util.UUID
import scala.reflect.ClassTag
import scala.language.experimental.macros
import scala.language.existentials
import java.io.File
import xerial.lens.ObjectSchema
import xerial.silk.SilkException._
import scala.reflect.runtime.{universe=>ru}
import xerial.core.log.{LoggerFactory, Logger}
import xerial.silk.core._
import xerial.silk.core.CommandOp
import scala.util.{Success, Failure, Try}

object Silk extends Logger {

  implicit class SilkSeqWrap[A](val a:Seq[A]) {
    def toSilk : SilkSeq[A] = macro SilkMacros.mRawSeq[A]
  }

  implicit class SilkArrayWrap[A](val a:Array[A]) {
    def toSilk : SilkSeq[A] = macro SilkMacros.mArrayToSilk[A]
  }

  implicit class SilkWrap[A](val a:A) {
    def toSilkSingle : SilkSingle[A] = macro SilkMacros.mNewSilkSingle[A]
  }

  implicit class CommandBuilder(val sc:StringContext) extends AnyVal {
    def c(args:Any*) : CommandOp = macro SilkMacros.mCommand
  }

  implicit class SQLBuilder(val sc:StringContext) extends AnyVal {
    def sql(string:Any*) : SilkSeq[AnyRef] = null
  }

  /**
   * Import another workflow trait as a mixin to the caller class. The imported workflow shares the same session
   * @param ev
   * @tparam A
   * @return
   */
  def mixin[A](implicit ev:ClassTag[A]) : A with Workflow = macro WorkflowMacros.mixinImpl[A]

  def workflow[A](implicit ev:ClassTag[A]) : A with Workflow = macro WorkflowMacros.newWorkflowImpl[A]


  def empty[A] = Empty
  private[silk] def emptyFContext = FContext(classOf[Silk[_]], "empty", None, None, "", 0, 0)

  object Empty extends SilkSeq[Nothing] {
    override val id = UUID.nameUUIDFromBytes("empty".getBytes)
    def fc = emptyFContext
  }


  def openFile(file:String) : LoadFile = macro SilkMacros.loadImpl
  def open(file:File) : LoadFile = macro SilkMacros.open
  def loadAs[A](file:String) : SilkSeq[A] = NA


  def newSilk[A](in:Seq[A]) : SilkSeq[A] = macro SilkMacros.mNewSilk[A]

  def scatter[A](in:Seq[A], numNodes:Int) : SilkSeq[A] = macro SilkMacros.mScatter[A]

  /**
   * Shuffle the two input sequences then merge them
   * @param a
   * @param b
   * @param probeA
   * @param probeB
   * @tparam A
   * @tparam B
   * @return
   */
  def shuffleMerge[A, B](a:SilkSeq[A], b:SilkSeq[B], probeA:A=>Int, probeB:B=>Int) : SilkSeq[(Int, SilkSeq[A], SilkSeq[B])] = macro SilkMacros.mShuffleMerge[A, B]


  /**
   * List files matching a give glob pattern.
   * @param pattern
   * @return
   */
  def file(pattern:String) : SilkSeq[File] = macro SilkMacros.mFiles

  /**
   * List directories matching a given glob pattern.
   * @param pattern
   * @return
   */
  def dir(pattern:String) : SilkSeq[File] = macro SilkMacros.mDirs

}



/**
 * Silk[A] is an abstraction of a set of data elements of type A, which might be distributed
 * over cluster nodes.
 *
 * Silk[A] is a base trait for all Silk data types.
 *
 * We do not define operations on Silk data in this trait,
 * since map, filter etc. needs macro-based implementation, which cannot be used to override
 * interface methods.
 *
 * @tparam A element type
 */
trait Silk[+A] extends Serializable with IDUtil {

  /**
   * ID of this operation. To provide stable IDs for each run, the id should be generated by using
   * the input IDs of this operation and FContext.
   *
   * For
   *
   * @return
   */
  val id: UUID // = SilkUtil.newUUIDOf(fc, inputs:_*)

  override def hashCode = id.hashCode()

  override def equals(obj:Any) : Boolean = {
    obj match {
      case s:Silk[_] => id == s.id
      case other => false
    }
  }

  /**
   * Dependent input Silk data
   * @return
   */
  def inputs : Seq[Silk[_]] = {
    val b = Seq.newBuilder[Silk[_]]
    this match {
      case p:Product => p.productIterator.foreach{
        case s:Silk[_] => b += s
        case _ =>
      }
    }
    b.result
  }

  def idPrefix = id.prefix

  def save : SilkSingle[File] = NA


  /**
   * Byte size of the given input
   */
  def byteSize : SilkSingle[Long] = NA

  /**
   * Returns Where this Silk operation is defined. A possible value of fc is a variable or a function name.
   */
  def fc: FContext

  def isSingle : Boolean

  override def toString = {
    val cl = this.getClass

    val params : Seq[Any] = Try {
      val schema = ObjectSchema(cl)
      val ct = schema.findConstructor
      if(ct.isEmpty)
        Seq.empty
      else {
        val res = for {p <- ct.get.params
             if p.name != "id" &&  p.name != "ss" && p.valueType.rawType != classOf[ClassTag[_]]
             v = p.get(this) if v != null} yield {
          if (classOf[ru.Expr[_]].isAssignableFrom(p.valueType.rawType)) {
            s"${v}[${v.toString.hashCode}]"
          }
          else if (classOf[Silk[_]].isAssignableFrom(p.valueType.rawType)) {
            s"[${v.asInstanceOf[Silk[_]].idPrefix}]"
          }
          else
            v
        }
        res.toSeq
      }
    } match {
      case Success(x) => x.asInstanceOf[Seq[Any]]
      case Failure(e) => {
        val logger = LoggerFactory(cl)
        logger.error(s"toString of $cl failed: ${e.getMessage}")
        Seq.empty
      }
    }

    val prefix = s"[$idPrefix]"
    val s = s"${cl.getSimpleName}(${params.mkString(", ")})"
    //    val fv = freeVariables
    //    val fvStr = if (fv == null || fv.isEmpty) "" else s"{${fv.mkString(", ")}}|= "
    s"$prefix $s"
  }


  def toSilkString : String = {
    val s = new StringBuilder
    mkSilkText(0, s)
    s.result.trim
  }


  private def mkSilkText(level:Int, s:StringBuilder)  {
    def indent(n:Int) : String = {
      val b = new StringBuilder(n)
      for(i <- 0 until n) b.append(' ')
      b.result
    }

    val sc = ObjectSchema.apply(getClass)
    val idt = indent(level)
    s.append(s"${idt}-${sc.name}\n")
    for(p <- sc.constructor.params) {
      val v = p.get(this)
      val idt = indent(level+1)
      v match {
        case f:Silk[_] =>
          s.append(s"$idt-${p.name}\n")
          f.mkSilkText(level+2, s)
        case e:ru.Expr[_] =>
          s.append(s"$idt-${p.name}: ${ru.show(e)}\n")
        case _ =>
          s.append(s"$idt-${p.name}: $v\n")
      }
    }
  }


  /**
   * Assign a new ID to this operation to enforce recomputing the same function
   * @return
   */
  def touch : this.type = {
    val sc = ObjectSchema(this.getClass)
    val params = for(p <- sc.constructor.params) yield {
      val v = p.get(this)
      val newV = if(p.name == "id") {
        // Create a stable UUID based on the previous ID
        SilkUtil.newUUIDFromString(v.toString+"-touch")
      }
      else
        v
      newV.asInstanceOf[AnyRef]
    }
    val c = sc.constructor.newInstance(params.toSeq.toArray[AnyRef])
    c.asInstanceOf[this.type]
  }

  def forceEval : this.type = {
    val sc = ObjectSchema(this.getClass)
    val params = for(p <- sc.constructor.params) yield {
      val v = p.get(this)
      val newV = if(p.name == "id") {
        // Create a stable UUID based on the previous ID
        SilkUtil.newUUID
      }
      else
        v
      newV.asInstanceOf[AnyRef]
    }
    val c = sc.constructor.newInstance(params.toSeq.toArray[AnyRef])
    c.asInstanceOf[this.type]
  }


}







